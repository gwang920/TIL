<<<<<<< HEAD
# 백준 11724 연결 요소의 개수

- 카테고리 : dfs
- dfs에서 꼬리물기로 연결요소를 파악한다



# 성공

```c++
=======


# 백준 11724 연결 요소의 개수









```
>>>>>>> 72a030a5dbea7932827e5e2bff753f92254d57c6
#include <iostream>
#include <vector>

using namespace std;

vector<int> v[1001];

<<<<<<< HEAD
int visited[1001];
int N, M;
int U, V;
int cnt = 0;

void dfs(int k) {

		for (int j = 0;j < v[k].size();j++) {
			if (v[k][j] && !visited[v[k][j]]) {

				visited[v[k][j]] = 1;
				dfs(v[k][j]);
				
			}
		}
	
}

int main() {

	cin >> N >> M;

	for (int i = 0;i < M;i++) {

		cin >> U >> V;
		v[U].push_back(V);
	    v[V].push_back(U);

	}
	for (int i = 1;i <= N;i++) {
		if (!visited[i]) {
			cnt++;
			dfs(i);
		}
	}
	cout << cnt << "\n";
	return 0;
=======
int N,M;
int U,V;
int cnt=0;
int flag;

int main(){
	
	cin >> N >> M;
	
	for(int k=0;k<M;k++){
		
		cin >> U >> V;
		flag=0;
		if(k==0){
			
			v[k].push_back(U);
			v[k].push_back(V);
			cnt++;
		}
		
		else{			
		for(int i=0;i<k;i++){
		
			for(int j=0;j<v[i].size();j++){
				
				if(v[i][j]==U || v[i][j]==V){
					
					v[i].push_back(U);
					v[i].push_back(V);
					flag=1;
					break;
				}
			
			}
		}
		if(!flag){
			cnt++;
			v[k].push_back(U);
			v[k].push_back(V);
			
		}
		}
	
	}
	cout << cnt;
	
	return 0;
	
>>>>>>> 72a030a5dbea7932827e5e2bff753f92254d57c6
}
```

