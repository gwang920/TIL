# 프로그래머스 섬 연결하기

- 카테고리 : 탐욕법(greedy)
- 탐욕법이라는 알고리즘을 적용해서 단계적으로 최적해를 찾아 나가는 방식을 이용
- 코드를 3번정도 리셋(재귀 풀이, 반복문풀이)
- 굳이 'queue'를 쓰지 않아도 구현할 수 있다고 생각한다





# 실패

-   if(arr[i][j]==0 || check_sum[i][j]) continue; 해당 라인을 check할 때 방문했던 섬은 continue 해주는 코드가 없었다

```c++
#include <string>
#include <vector>
#include <queue>

using namespace std;

queue<pair<int,int>> q;

int arr[100][100]={(0,0),};
int cost=0,now_y=0,now_x=0;
int min_check=9999;
int visited[100]={0,};
int check_sum[100][100];

int check(int n){
    for(int i=0;i<n;i++){
        if(!visited[i]) return false;
        // return true;    서순 차이
    }
    return true;
}

int solution(int n, vector<vector<int>> costs) {
    
    
    for(int i=0;i<costs.size();i++){
        
        if(min_check>costs[i][2]){
            min_check=costs[i][2];
            
            now_y=costs[i][0];
            now_x=costs[i][1];
        }
        
        arr[costs[i][0]][costs[i][1]]=costs[i][2];
        arr[costs[i][1]][costs[i][0]]=costs[i][2];   
    }
    
    q.push({now_y,now_x});
    
    while(!q.empty()){
         
        if(check(n)) return cost;
        
         auto now=q.front();
         now_y=now.first;
         now_x=now.second;
         q.pop();
    
        // 방문처리
        visited[now_y]=1;
        visited[now_x]=1;
        
        check_sum[now_y][now_x]=1;
        check_sum[now_x][now_y]=1;
        
        // 합계
        
        cost+=arr[now_y][now_x];
        
        min_check=9999;
        
        // 가장 짧은경로 찾기
        for(int i=0;i<n;i++){   
            
            if(visited[i]!=0){
                
                for(int j=0;j<n;j++){
                    
                    // 이미 더해준 경로, 길이없는 경우는 무시, 
                    if(arr[i][j]==0 || check_sum[i][j]) continue;
                    
                    if(min_check>arr[i][j])
                    {   
                        min_check=arr[i][j];
                        now_y=i;
                        now_x=j;
                        
                        }
                }
            }
        }
        q.push({now_y,now_x});
    }
}
```



# 성공

```c++
#include <string>
#include <vector>
#include <queue>

using namespace std;

queue<pair<int,int>> q;

int arr[100][100]={(0,0),};
int cost=0,now_y=0,now_x=0;
int min_check=9999;
int visited[100]={0,};
int check_sum[100][100];

int check(int n){
    for(int i=0;i<n;i++){
        if(!visited[i]) return false;
        // return true;    서순 차이
    }
    return true;
}

int solution(int n, vector<vector<int>> costs) {
    
    
    for(int i=0;i<costs.size();i++){
        
        if(min_check>costs[i][2]){
            min_check=costs[i][2];
            
            now_y=costs[i][0];
            now_x=costs[i][1];
        }
        
        arr[costs[i][0]][costs[i][1]]=costs[i][2];
        arr[costs[i][1]][costs[i][0]]=costs[i][2];   
    }
    
    q.push({now_y,now_x});
    
    while(!q.empty()){
         
        if(check(n)) return cost;
        
         auto now=q.front();
         now_y=now.first;
         now_x=now.second;
         q.pop();
    
        // 방문처리
        visited[now_y]=1;
        visited[now_x]=1;
        
        check_sum[now_y][now_x]=1;
        check_sum[now_x][now_y]=1;
        
        // 합계
        
        cost+=arr[now_y][now_x];
        
        min_check=9999;
        
        // 가장 짧은경로 찾기
        for(int i=0;i<n;i++){   
            
            if(visited[i]!=0){
                
                for(int j=0;j<n;j++){
                    
                    // 이미 더해준 경로, 길이없는 경우는 무시, 
                    if(arr[i][j]==0 || check_sum[i][j] || visited[j]) continue;
                    
                    if(min_check>arr[i][j])
                    {   
                        min_check=arr[i][j];
                        now_y=i;
                        now_x=j;
                        
                        }
                }
            }
        }
        q.push({now_y,now_x});
    }
}
```



