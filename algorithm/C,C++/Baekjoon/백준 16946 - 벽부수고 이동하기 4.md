# 백준 16946 - 벽 부수고 이동하기 4

- 카테고리 : BFS



# 실패

```c++
#include <stdio.h>
#include <vector>
#include <string.h>
#include <queue>
using namespace std;

vector<pair<int,int>> v,c;
queue<pair<int,int>> q;
const int dy[]={0,1,0,-1},dx[]={1,0,-1,0};
int N,M,count,order;
int map[1001][1001],backup[1001][1001];
int visit[1001][1001],visit_order[1001];
void game(){
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			count=0;
			if(map[i][j]) continue;
			order++; q.push({i,j}); c.push_back({i,j});
			while(!q.empty()){
				auto now=q.front();q.pop();
				int y=now.first,x=now.second;
				for(int k=0;k<4;k++){
					int ny=y+dy[k],nx=x+dx[k];
					if(ny<0 || nx<0 || ny>N-1 || nx>M-1 || visit[ny][nx]!=0) continue;
					visit[ny][nx]=1; c.push_back({ny,nx});
					q.push({ny,nx}); count++;
				}
			}
			
			for(int k=0;k<c.size();k++){
				int y=c[k].first,x=c[k].second;
				backup[y][x]=order;
				if(count==0){
					map[y][x]=1; continue;	
				} 
				map[y][x]=count;
			}
			c.clear();
		}
	}
	for(int i=0;i<v.size();i++){
		int y=v[i].first,x=v[i].second,sum=0;
		for(int k=0;k<4;k++){
			int ny=y+dy[k],nx=x+dx[k];
			if(ny<0 || nx<0 || ny>N-1 || nx>M-1 || visit[ny][nx]==-1) continue;
			if(visit_order[backup[ny][nx]]) continue;
			visit_order[backup[ny][nx]]=1;
			sum+=map[ny][nx];
		}
		memset(visit_order,0,sizeof(visit_order));
		map[y][x]=(sum+1)%10;	
	}
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			if(visit[i][j]!=-1) map[i][j]=0;
		}
	}
}

int main(){
	scanf("%d %d",&N,&M);
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			int tmp;
			scanf("%1d",&tmp);
			if(tmp==1){
				map[i][j]=-1; visit[i][j]=-1;	
			} 
			if(map[i][j]==-1) v.push_back({i,j});
		}
	}
	game();
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			printf("%d",map[i][j]);
		}
		printf("\n");
	}
	
	return 0;
}
```

