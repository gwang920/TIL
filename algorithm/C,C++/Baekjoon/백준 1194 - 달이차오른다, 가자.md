



# dfs 실패

```c++
#include <iostream>
#include <queue>
#include <algorithm>
#include <vector>
#define MAX 51
using namespace std;

queue<pair<int,int>> q;
vector <pair<int,int>> door[MAX];
const int dy[]={0,1,0,-1},dx[]={1,0,-1,0};
int N,M,sy,sx,res=987654321,key[MAX];
char map[MAX][MAX];
bool visit[MAX][MAX][4],backup[MAX][MAX][4];

void game(int y,int x,int cnt){
	for(int dir=0;dir<4;dir++){
		int ny=y+dy[dir],nx=x+dx[dir];
		if(ny<0 || nx<0 || ny>N-1 || nx>M-1) continue;
		if(visit[ny][nx][dir] || map[ny][nx]=='#') continue;
			if(map[ny][nx]=='1'){
				res=min(res,cnt+1);
				return;
			}
			visit[ny][nx][dir]=1;
			if(map[ny][nx]=='.' || map[ny][nx]=='0'){
				game(ny,nx,cnt+1);
			}
			if(map[ny][nx]>='a' && map[ny][nx]<='z'){
				key[map[ny][nx]-'a']=1;
				game(ny,nx,cnt+1);
				for(int i=0;i<door[map[ny][nx]-'a'].size();i++){
					int door_y=door[map[ny][nx]-'a'][i].first;
					int door_x=door[map[ny][nx]-'a'][i].second;
					int dist=abs(ny-door_y)+abs(nx-door_x);
					game(door_y,door_x,cnt+1+dist);
					key[map[ny][nx]-'a']=0;
				}
				
			}
			if(map[ny][nx]>='A' && map[ny][nx]<='Z'){
				if(key[map[ny][nx]-'A']){
					game(ny,nx,cnt+1);
				}else{
					door[key[map[ny][nx]-'A']].push_back({ny,nx});
				}
			}
			visit[ny][nx][dir]=0;
	}
}

int main(){
	cin >> N >> M;
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			cin >> map[i][j];
			if(map[i][j]-'0'==0){
				sy=i; sx=j;
			}
		}
	}
	game(sy,sx,0);
	if(res==987654321){
		cout << -1 << endl;
	}else{
		cout << res << endl;
	}
	return 0;
}
```



# bfs 실패

```c++
#include <iostream>
#include <queue>
#include <algorithm>
#include <vector>
#define MAX 51
using namespace std;

typedef pair<int,pair<int,int>> PAIR;
queue<PAIR> q;
vector<PAIR> door[MAX],key[MAX];
const int dy[]={0,1,0,-1},dx[]={1,0,-1,0};
int N,M,sy,sx,res=987654321;
char map[MAX][MAX];
bool visit[MAX][MAX][4];

int calc(int d_y,int d_x,int y,int x){
	queue<PAIR> cq;
	bool visit[MAX][MAX]={0,};
	cq.push({0,{y,x}});
	while(!cq.empty()){
			auto now=cq.front(); cq.pop();
			int cnt=now.first;
			for(int i=0;i<4;i++){
				int ny=now.second.first+dy[i],nx=now.second.second+dx[i];
				if(ny<0 || nx<0 || ny>N-1 || nx>M-1) continue;
				if(visit[ny][nx] || map[ny][nx]=='#') continue;
				if(ny==d_y && nx==d_x) return cnt+1;
				visit[ny][nx]=1;
				cq.push({cnt+1,{ny,nx}});
			}
	}	
}

void game(){
	q.push({0,{sy,sx}});
	while(!q.empty()){
		auto now=q.front(); q.pop();
		int cnt=now.first,y=now.second.first,x=now.second.second;
		for(int i=0;i<4;i++){
			int ny=y+dy[i],nx=x+dx[i];
			if(ny<0 || nx<0 || ny>N-1 || nx>M-1) continue;
			if(visit[ny][nx][i] || map[ny][nx]=='#') continue;
			visit[ny][nx][i]=1;
			if(map[ny][nx]=='1'){
				res=min(res,cnt+1); 
			}
			if(map[ny][nx]=='0' || map[ny][nx]=='.'){
				q.push({cnt+1,{ny,nx}});
			}
			if(map[ny][nx]>='a' && map[ny][nx]<='z'){
				int loc=map[ny][nx]-'a';
				q.push({cnt+1,{ny,nx}});
				key[loc].push_back({cnt+1,{ny,nx}});
				if(door[loc].size()){
					for(int j=0;j<door[loc].size();j++){
						int door_y=door[loc][j].second.first,door_x=door[loc][j].second.second;
						int ncnt=key[loc][0].first;
						int dist=calc(door_y,door_x,ny,nx);
						q.push({ncnt+dist,{door_y,door_x}});		
					}
				}
			}
			if(map[ny][nx]>='A' && map[ny][nx]<='Z'){
				int loc=map[ny][nx]-'A';
				if(key[loc].size()){
					int k_y=key[loc][0].second.first,k_x=key[loc][0].second.second;
					int ncnt=key[loc][0].first;
					int dist=calc(ny,nx,k_y,k_x);
					q.push({dist+ncnt,{ny,nx}});
				}else{
					door[loc].push_back({cnt+1,{ny,nx}});
				}
			} 
		}
	}
}

int main(){
	cin >> N >> M;
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			cin >> map[i][j];
			if(map[i][j]-'0'==0){
				sy=i; sx=j;
			}
		}
	}
	game();
	if(res==987654321){
		cout << -1 << endl;
	}else{
		cout << res << endl;
	}
	return 0;
}
```

