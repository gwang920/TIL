# 백준 16236 아기상어

- 카테고리 : BFS
- 자잘한조건을 놓치지말자
- 설계 꼼꼼하게 하자

```

탐색(bfs) -> 출발지점 갱신(dfs - 먹은 위치부터) -> 탐색(bfs) -> 출발지점 갱신(dfs - 먹은 위치부터) -> ... 

1) DFS로 출발지점,크기,먹은갯수 갱신해 나간다.
2) 출발지점부터 BFS로 먹을 수 있는 놈을 탐색한다. (BACKUP배열에 이동경로마다 시간을 기록한다.)
3) 먹을 수 있는 놈을 최초로 찾으면 이동을 멈춘다.(q.push x)
4) 먹을 수 있는 놈들 중 가장 짧은 거리와 조건을 만족하는 놈을 찾는다.
5) 고기를 먹고, 갱신 된 값(출발지점,크기,먹은갯수)을 기준으로 다시 DFS로 탐색 + 초기화(backup배열)
6) 1) ~ 5) 반복한다.
```



- 실패코드는 더 긴 거리를 선택한다. 거리를 고려하지 않아서

```c++
map[][]

0000
0955
0002
3300

backup[][]

2123
1912
2123
3234


(3,1) 의 3을 선택하지 않고 (2,3)의 2를 선택한다. 
(거리를 고려하지 않고 단순히 가장 위에 있는놈을 선택했다.)
    
단순히 backup배열로 시간을 기록하면 '거리가 같을 때' 라는 조건을 자동으로 만족시켜준다고 생각했다.
 
```



# 실패

```c++
#include <iostream>
#include <queue>
#define MAX 20

using namespace std;

queue<pair<int,int>> q;
const int dy[]={0,1,0,-1};
const int dx[]={1,0,-1,0};

int N;
int map[MAX][MAX];
int backup[MAX][MAX];
int start_y,start_x;
int time=0;


void init(){
	
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			backup[i][j]=0;
		}
	}
	return;
}
 
void move(int s_y,int s_x,int size,int count){
	
	q.push({s_y,s_x}); 
	bool flag=false;
	int eat_y=21;int eat_x=21;
	while(!q.empty()){
		if(flag==true){
			while(!q.empty()){
				q.pop();	
			} 
			break;	
		} 
		auto now=q.front(); q.pop();
		int y=now.first; int x=now.second;
		
		for(int i=0;i<4;i++){
			int ny=y+dy[i]; int nx=x+dx[i];
			if(ny<0 || nx<0 || ny>N-1 || nx>N-1) continue;
			if(backup[ny][nx]!=0 || (s_y==ny && s_x==nx) || map[ny][nx]>size) continue;
			backup[ny][nx]=backup[y][x]+1;
			if(map[ny][nx]==0 || map[ny][nx]==size){
				q.push({ny,nx}); 
			}
			else if(map[ny][nx]<size){
				flag=true;
				if(eat_y>=ny){
					if(eat_y==ny){
						if(eat_x>nx){
							eat_y=ny; eat_x=nx;
						}
					}else{
						eat_y=ny; eat_x=nx;	
					}
				}
			}
		}
}
	if(flag==true){
		map[eat_y][eat_x]=0; time+=backup[eat_y][eat_x];
		count++;
		init();
		if(count==size){
			move(eat_y,eat_x,size+1,0);
			
		}else{
			move(eat_y,eat_x,size,count);
		}
	}
}
 
 
int main(){
	cin >> N;
	
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			cin >> map[i][j];
			if(map[i][j]==9){
				map[i][j]=0;
				start_y=i; start_x=j;
			}
		}
	}
	move(start_y,start_x,2,0);
	cout << time << endl;
	
	return 0;
}
```



# 성공

```C++
#include <iostream>
#include <queue>
#define MAX 20

using namespace std;

queue<pair<int,int>> q;
const int dy[]={0,1,0,-1};
const int dx[]={1,0,-1,0};

int N;
int map[MAX][MAX];
int backup[MAX][MAX];
int start_y,start_x;
int time=0;

void init(){
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			backup[i][j]=0;
		}
	}
	return;
}
 
void move(int s_y,int s_x,int size,int count){
	q.push({s_y,s_x}); 
	bool flag=false; int eat_y=21;int eat_x=21; int dist=987654321;
	while(!q.empty()){
		auto now=q.front(); q.pop();
		int y=now.first; int x=now.second;
		for(int i=0;i<4;i++){
			int ny=y+dy[i]; int nx=x+dx[i];
			if(ny<0 || nx<0 || ny>N-1 || nx>N-1) continue;
			if(backup[ny][nx]!=0 || (s_y==ny && s_x==nx) || map[ny][nx]>size) continue;
			backup[ny][nx]=backup[y][x]+1; // 이동경로 시간 기록
			if(map[ny][nx]==0 || map[ny][nx]==size){ // 이동할 수 있다면
				if(!flag) q.push({ny,nx}); // 먹을놈을 찾았으면 
			}
			else if(map[ny][nx]<size){ // 먹을 수 있다면
				flag=true;
				if(eat_y>=ny && dist>=backup[ny][nx]){ // 조건을 만족하면서, 가장 짧은거리 찾자
					if(eat_y==ny){
						if(eat_x>nx){
							eat_y=ny; eat_x=nx; dist=backup[ny][nx];
						}
					}else{
						eat_y=ny; eat_x=nx;	dist=backup[ny][nx];
					}
				}
			}
		}
	}

	if(flag==true){
		map[eat_y][eat_x]=0; time+=backup[eat_y][eat_x];
		count++; init();
		if(count==size){
			move(eat_y,eat_x,size+1,0);
		}else{
			move(eat_y,eat_x,size,count);
		}
	}
}
 
 
int main(){
	cin >> N;
	
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			cin >> map[i][j];
			if(map[i][j]==9){
				map[i][j]=0; start_y=i; start_x=j;
			}
		}
	}
	move(start_y,start_x,2,0);
	cout << time << endl;
	
	return 0;
}
```

