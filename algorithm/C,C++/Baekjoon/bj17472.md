# 백준 17472 다리 만들기2



# 실패

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#define MAX 11

using namespace std;

queue<pair<int,int>> q;
vector<pair<int,int>> v[MAX];       
const int dy[]={0,1,0,-1};
const int dx[]={1,0,-1,0};

int N,M;
int map[MAX][MAX];
int visit[MAX];
int visited[MAX][MAX];
int cnt=1,check=1;
int answer=0;

void Connect(){
	int minn=987654321;
	int start_cnt=0,end_cnt=0;
	for(int i=2;i<=cnt;i++){	
		for(int j=0;j<v[i].size();j++){
		    int y=v[i][j].first; int x=v[i][j].second;
		    for(int k=0;k<4;k++){
				int ny=y; int nx=x;
				while(1){
					ny+=dy[k]; nx+=dx[k];
		    		if(map[ny][nx]==i || ny<0 || nx<0 || ny>N-1 || nx>M-1) break;
		    		if(map[ny][nx]!=0 && map[ny][nx]!=i){
		    			int dist=abs(ny-y)+abs(nx-x)-1;
		    			if(dist<2) break;
		    			if(minn>=dist){
		    				start_cnt=i;
						}
						break;
					}
				}
			}
		    
		}
	}	
	visit[start_cnt]=1;
	
	while(1){
		if(check==cnt-1) return;
		bool flag=false;
		for(int i=2;i<=cnt;i++){
			if(visit[i]){		
				for(int j=0;j<v[i].size();j++){	
					int y=v[i][j].first; int x=v[i][j].second;
					for(int k=0;k<4;k++){
						int ny=y; int nx=x;
						while(1){
								ny+=dy[k]; nx+=dx[k];
		    					if(map[ny][nx]==i || ny<0 || nx<0 || ny>N-1 || nx>M-1) break;
		    					if(map[ny][nx]!=0 && map[ny][nx]!=i){
		    					if(visited[i][map[ny][nx]]) break;
		    					int dist=abs(ny-y)+abs(nx-x)-1;
		    					if(dist<2) break;
		    					if(minn>=dist){
		    						minn=dist; start_cnt=map[y][x]; end_cnt=map[ny][nx];
								}
								break;
							}
						}
					}
				}	
			}
		}
		
			visited[start_cnt][end_cnt]=1; visited[end_cnt][start_cnt]=1;
			check++; answer+=minn; visit[end_cnt]=1;
			minn=987654321;
	}
}

void Counting(){
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			if(map[i][j]==1){
				q.push({i,j}); cnt++; map[i][j]=cnt;
				while(!q.empty()){
					auto now= q.front();q.pop();
					int y=now.first; int x=now.second;
					for(int k=0;k<4;k++){
						int ny=y+dy[k]; int nx=x+dx[k];
						if(ny<0 || nx<0 || ny>N-1 || nx>M-1) continue;
						if(map[ny][nx]==1){
							map[ny][nx]=cnt; q.push({ny,nx});
						}
						if(map[ny][nx]==0){
							v[cnt].push_back({y,x});
						}
					}
				}
			}
		}
	}
}

int main(){
	
	cin >> N >> M;
	
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			cin >> map[i][j];
		}
	}
	
	Counting();
	Connect();
	
	cout << answer << endl;
	bool flag=true;
	for(int i=2;i<cnt;i++){
		if(!visit[i]){
			flag=false; break;
		} 	
	}
	
	if(!flag){
		cout << "-1" << endl;
	}else{
		cout << answer << endl;
	}

	
	return 0;
}
```

