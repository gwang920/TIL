# SWEA - 2112 보호필름

- 카테고리 : 완전탐색 ( 백트래킹 )







```C++
따지고 보면 case1 ,case2는 같은 코드인 것같지만 case1은 오답이 된다.


[CASE 1]
void dfs(int idx){
	if(idx>res) return;
	if(idx>k) return;
	if(check()){
		res=min(res,idx);
		return;
	}
	
	
	for(int i=0;i<d;i++){
		for(int j=0;j<=1;j++){
			if(visit[i]) continue;
			memcpy(backup,map,sizeof(map));
			visit[i]=1;
			inp(i,j);
			dfs(idx+1);
			visit[i]=0;
			memcpy(map,backup,sizeof(map));
		}
	}
}

[오답]

[CASE 2]
void dfs(int idx){
	if(idx>res) return;
	if(idx>k) return;
	if(check()){
		res=min(res,idx);
		return;
	}
	
	
	for(int i=0;i<d;i++){
		for(int j=0;j<=1;j++){
			if(visit[i]) continue;
			for(int k=0;k<w;k++){
				backup[i][k]=map[i][k];
				map[i][k]=j;
			}
			visit[i]=1;
			inp(i,j);
			dfs(idx+1);
			visit[i]=0;
			for(int k=0;k<w;k++){
				map[i][k]=backup[i][k];
			}
		}
	}
}


[정답]
```



# 실패(시간초과)

```c++
#include <iostream>
#include <string.h>
using namespace std;

int T,res,d,w,k;
bool map[13][20],backup[13][20],visit[13];

bool check(){
	for(int i=0;i<w;i++){
		bool ch=true;
		for(int j=0;j<=d-k;j++){
			if(map[j][i]!=map[j+1][i]) continue;
			ch=true;
			for(int t=j+1;t<k+j;t++){
				if(map[j][i]!=map[t][i]){
					ch=false;break;	
				}
			}
			if(i==w-1 && ch) return true;
			if(ch) break;
		}
		if(!ch) return false;
	}
}

void inp(int idx,bool type){
	for(int i=0;i<w;i++){
		if(map[idx][i]==type) continue;
		map[idx][i]=type;
	}
}

void dfs(int idx,int cnt){
	if(idx>=res) return;
	if(check()){
		res=idx;
		return;
	}
	if(idx>=cnt || idx>=k) return;
	for(int i=0;i<d;i++){
		if(visit[i]) continue;
		for(int k=0;k<w;k++){
			backup[i][k]=map[i][k];
		}
		for(int j=0;j<=1;j++){
			for(int k=0;k<w;k++){
				map[i][k]=j;
			}
			visit[i]=1;
			inp(i,j);
			dfs(idx+1,cnt);
			visit[i]=0;
		}
		for(int k=0;k<w;k++){
			map[i][k]=backup[i][k];
		}
	}
}


int main(){
	cin >> T;
	for(int tc=1;tc<=T;tc++){
		cin >> d >> w >> k;
		for(int i=0;i<d;i++){
			for(int j=0;j<w;j++){
				cin >> map[i][j];
			}
		}
		res=987654321;
		if(check() || k==1) res=0;
		else{
			int cnt=1;
			while(cnt<=k){
				if(res<=cnt) break;
				dfs(0,cnt);
				cnt++;
			}
		}
		memset(visit,0,sizeof(visit));
		cout << "#" << tc << ' ' << res << endl;
	}
	return 0;
}
```

