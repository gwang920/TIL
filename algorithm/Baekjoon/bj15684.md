# 백준 - 15684 사다리 조작







# 실패

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

queue<pair<pair<int,int>,int>> q;

const int dx[]={1,-1};
const int dy[]={0,0};

int Bridge[31][11][11];
int visited[31][11][11];
int N,M,H;
bool flag=true;

void init(){
	for(int i=1;i<=H;i++){
		for(int j=1;j<=N;j++){
			for(int k=1;k<=N;k++){
				visited[i][j][k]=0;			
			}
		}
	}
	return;
}

// 결과 확인
void Check(int Idx){
	
	q.push({{1,Idx},1});   // y x H
	
	while(!q.empty()){
		auto now=q.front(); q.pop();
		int y=now.first.first; int x=now.first.second; int h=now.second;
		if(h==H+1){
			if(Idx==x){
			//	cout << x << " ";
				return;
			}else{
				flag=false;
				return;
			}
		}
		bool Bridge_move=false;
		for(int i=0;i<2;i++){
			int ny=y+dy[i]; int nx=x+dx[i];
			if(ny>N || nx>N || h>H) continue;
			if(ny==nx) continue;
			if(Bridge[h][ny][nx] && !visited[h][ny][nx]){
				visited[h][ny][nx]=1; visited[h][nx][ny]=1;
				q.push({{nx,nx},h});
				Bridge_move=true;
			}
		}
		if(Bridge_move) continue;
		q.push({{y,x},h+1});
	}
} 

// 다리 연결 - 모든 경우의 수 
void Connect(int Count,int Goal){
	
	if(Count==Goal){
		flag=true;
		for(int i=1;i<=N;i++){
			init();
			Check(i);
		}
		if(flag){
			cout << Goal;
		}
		return;
	}
	
	for(int i=1;i<=H;i++){
		for(int j=1;j<N;j++){
			for(int k=j+1;k<j+2;k++){
					if((k-j)!=1) continue;
					if(!Bridge[i][j-1][j] && !Bridge[i][j][k] && !Bridge[i][k][k+1]){
						Bridge[i][j][k]=1; Bridge[i][k][j]=1;
						Connect(Count+1,Goal);
						Bridge[i][j][k]=0; Bridge[i][k][j]=0;			
				}	
			}
		}
	}
}

int main(){
	
	cin >> N >> M >> H;
	
	for(int i=0;i<M;i++){
		int a,b;
		cin >> a >> b;
		Bridge[a][b][b+1]=1;
		Bridge[a][b+1][b]=1;
	}

	for(int i=0;i<4;i++){
		Connect(0,i);
		if(flag){
			cout << i << endl;
			return 0;
		}
	}
	
	cout << "-1" << endl;
	return 0;
}
```

