



##### 데이터베이스 성능 이슈

- 큰 데이터 열이 존재할 때 어떻게 해결할 것 인가
-  큰 크기의 열이 있으면 그만큼 많은 페이지를 읽어야 하고 어마어마한 데이터를 ‘사용하지 않더라도 읽어야 하는 것’



##### c++ / java 차이

- c++ 

장점 : 포인터에 의한 데이터 전달이 가능 , 속도가 빠름

단점 : 객체지향 개념이 java에 비해 약함

- java

장점 : 웹에 최적화 , 단순하며 높은 신뢰성을 제공하여 유지보수 편리

단점 : c++에 비해 속도가 느림 , 단일 상속 , 포인터가 없음



##### 정적바인딩 / 동적바인딩

  정적바인딩 : 컴파일 시간에 의해 성격이 결정되는 것 (실행효율이 높다)

  동적바인딩 : 실행 시간에 의해 성격이 결정되는 것 (적응성이 높다)



 지도의 상태를 최신으로 유지하고 실시간으로 변화를 읽어내는 것이 고정밀 지도의 핵심



##### 데이터 수집 → 후처리 작업  → 영상화

- 데이터는 후처리 후 흑백의 레이저 영상 이미지로 생성

- 데이터 후처리 과정에서는 생성된 영상 이미지에서 필요한 정보에 맞는 객체를 추출하는 작업 진행

고정밀 지도를 제작하기 위해서는 먼저 데이터 취득과 데이터 후처리 과정이 필요하다. 

앞서 설명한 하드웨어 센서들로 도로 및 주변 지형 등에 대한 데이터는 후처리 후 흑백의 레이저 영상 이미지로 생성된다. 

이 영상 이미지는 수백만 개의 포인트가 모여 완성되며 각각의 포인트는 위도와 경도 등 삼차원 공간 좌표로 이루어져 있다. 

데이터 후처리 과정에서는 생성된 영상 이미지에서 필요한 정보에 맞는 객체를 추출하는 작업을 한다. 

여기서 객체란 표지판, 차선 정보, 건물 외곽선, 도로노면 정보 등의 특정 속성값을 말한다. 

이러한 속성값을 계산해 가공한 다음 자동차 데이터베이스 포맷으로 변환하면 고정밀 지도를 완성할 수 있다.

고정밀 지도 제작은 여러 대의 자동차가 동일한 도로에서 여러 번 주행한 데이터를 합산해야 한다. 수집 횟수가 많아질수록 더 많은 데이터베이스가 축적돼 지도의 품질도 높아지게 된다. 해당 작업은 대부분 클라우드에서 이뤄진다. 하지만 데이터에 따른 '비용문제'는 고정밀 지도 제작의 큰 과제다. 



전문가들은 실시간으로 공유되어야 할 정보와 그렇지 않은 정보를 구분하는 것이 하나의 해결 방법이 될 수 있다고 제시한다. 운전에 실제로 영향을 주는 도로상 사고, 자연 재해에 따른 정보, 공사 정보 등 실시간 정보에 한해서만 셀룰러 네트워크를 통해 전달하는 것이다.









V2X와 정밀지도를 통해 센서 한계를 극복하고 동적인 정보를 실시간으로 송수신함으로써 완벽한 자율주행 구현을 위한 막대한 정보 획득 가능



##### 모바일엣지컴퓨팅

통신을 사용하려는 이용자와 가까운 곳에서 서버를 위치시켜 데이터를 처리하는 것
대용량의 정밀지도 데이터를 5G망을 통해 빠르게 전송하고, 다양한 인포테인먼트 서비스를 제공
정밀지도양산 / 실시간 업데이트





##### 공간데이터베이스 문제점

- 처리시간
  - 공간 데이터의 크기는 커지면서 요구하는 처리 시간은 점점 줄어들고 있다
- 데이터 품질
  - 데이터 일관성 제공, 중복성 제거, 데이터 생산 비용 절감 등



데이터로 차선 정보, 도로 곡률ㆍ경사

공간정보



구글 히어 애플

- 해당 기업이 제공하는 서비스 / 제품에 대한 높은 신뢰도가 가장 큰 장점

   아시아 시장에 약하다

  Reality Lens 솔루션을 통한 높은 매핍 데이터 신뢰성과 정확도







지오코딩

#### 객체지향프로그래밍

##### 추상화

- 자동차 <- 아우디 / 벤츠 
- 자동차는 추상의 대상이 된다
- 전체를  포함하는 일반화 된 대상이 추상화 대상
- 체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단

- 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미



- 구체적인 개념에 의존하는 경우

```java
switch(자동차 종류)
case 투싼: // 투싼 엔진 오일을 교환하는 과정을 기술
case 코나: // 코나 엔진 오일을 교환하는 과정을 기술
case 펠리세이드: // 펠리세이드 엔진 오일을 교환하는 과정을 기술
... 새로운 종류의 자동차가 나오면 계속해서 추가해야 한다.
end switch
```





- 추상적인 개념에 의존하는 경우

```java
void changeEngineOil(Car c) {
  c.changeEngineOil(); // 추상 메서드
}
```



changeEngineOil의 인자로 아우디, 벤츠의 추상화 개념인 “Car”을 사용한다.
이 코드는 어떤 새로운 종류의 자동차가 나와도 변경할 필요가 없다.
뒤에서 다룰 ‘다형성’의 원리에 따라 각 구체적인 클래스에서 오버라이드된 메서드(changeEngineOil)를 호출한다.



**[추상화****-abstraction]**

  \- 관심있는 부분만을 추출하여 형상화하는 것.

 

**[일반화** **- generalization]**



\- 추상화된 관심중에 공통된 성질만을 추출하여 형상화 하는 것.



##### 캡슐화

- 관련 있는 데이터와 함수를 하나의 단위로 묶는 것

**캡슐화**란 c++에서는 class 내부의 맴버 변수에 직접접근하는 방식이 아니라 간접적으로 맴버함수(매서드)를 사용하여 접근하는 형식을 말한다.

왜 직접 접근하지 않고 굳이 간접접근을 해야 하는걸까? 직접 접근하는 방식은 다른 객체에 의해 값이 변경될 수 도 있고 보안상 좋지 못한 방법이기 때문에 캡슐화의 정보은닉은 오류발생도 줄여주고 보안성을 향상시켜 준다.





1. 캡슐화는 데이터와 데이터를 처리하는 함수의 묶음이다.

2. 객체의 데이터를 직접 수정할수 없고 지정된 메서드를 통해서만 수정이 가능하다.(게터,세터)

3. 정보은닉으로 오류발생도 감소 및 보안성 향상이 된다.

```c++
class test_class{
private:
    int value;
public:
    void set_value(int value){
    this->value = value;
    }
    int get_value(){
    return this->value;
    }
};
```

캡슐화의 간단한 예시이다.

private 접근자를 사용하여 객체에서 직접 내부변수에 접근하지 못하게 하였고

세터(set_value)를 사용하여 변수의 값을 수정하며, 게터(get_value)를 사용하여 값을 가져온다.





c언어에서는 struct를 사용하여 변수에 대한 캡슐화만 가능하지만 , c++에서는 class를 사용하여 변수 뿐만 아니라 기능까지도 캡슐화 가능하다.



##### 상속

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 상속은 코드의 재사용성을 높이고, 코드의 중복을 제거하여 프로그램의 생산성/유지보수에 기여





```java
  class Tv {
	boolean power; 
    int channel;
      
    void channelUp(){ ++channel;}
  }

class CaptionTv extends Tv{
    boolean caption;
    void displayCaption(String text){
	if(caption){
		System.out.println(text);
        
    }
    }
}

class captionTest{
	CaptionTv ctv =new CaptionTv();
    ctv.channel=10;             //부모클래스로붙너 상속받은 멤버
    ctv.chnnelUp();				//부모클래스로붙너 상속받은 멤버
    System.out.println(ctv.channel);
}


실행결과
11
```





##### 다형성(polymorphism)

