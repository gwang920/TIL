## 프로세스 메모리 구조

| Kernel |
| :----: |
| Stack  |
|  Heap  |
|  Bss   |
|  Data  |
|  Code  |

![image](https://user-images.githubusercontent.com/49560745/89875199-ebeffc80-dbf7-11ea-9c45-05c419df4fdb.png)

​                                                          출처 : https://kyoun.tistory.com/34

```
1) Kernel

- 커널은 프로그램의 수행상태인 프로세스 간의 보안 접근을 책임지는 소프트웨어
- 커널이 이러한 프로세스마다 얼마만큼의 자원을 사용해야 하는지 결정해야하는데 이것을 스케줄링이라고 한다. 

2) Stack

- 프로그램이 자동으로 사용하는 임시 메모리 영역으로 '지역변수, 매개변수, 리턴 값' 등이 잠시 사용되었다가 사라지는 데이터를 저장하는 영역 함수 호출 시 생성되고 함수가 끝나면 반환된다. 
- Stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있어 런타임 시 Stack 사이즈를 바꿀 수 없다. 
- 명령 실행 시 자동으로 증가/감소하기 때문에 보통 메모리의 마지막 번지를 지정한다.

3) Heap

- 메모리를 동적 할당하고자 할 때 사용하는 메모리 영역
- 메모리 주소 값에 의해서만 참조되고 사용하는 영역 (ex: C언어 malloc)

4) Data

- 프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며 전역변수, 정적변수, 배열, 구조체 등이 저장된다.
- 초기화 된 데이터는 Data 영역에 저장되고 '초기화되지 않은 데이터는 BSS(Block Stated Symbol) 영역'에 저장된다. 
- 함수 내부에 선언된 Static 변수는 프로그램이 실행될 때 공간만 할당되고 그 함수가 실행될 때 초기화된다.

**** Data 영역과 BSS 영역을 구분하는 이유 **** 
프로그램을 짠 뒤 컴파일하고 링크하고 이미지로 만들어 시스템의 ROM에 저장했다고 가정해볼까요? 이 때 초기화된 데이터는 초기값을 저장해야 하니 Data 영역에 저장되어 ROM에 저장됩니다. 하지만 초기화하지 않은 데이터까지 ROM에 저장한다면 큰 사이즈의 ROM이 필요한데 비용이 많이 들어 RAM에 저장하기 위해 Data 영역과 BSS 영역으로 나눈 것입니다.

5) Code

- 코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일 메모리
- 간단하게 작성한 코드 전체가 Code 영역에 올라간다.

code, data, bss 영역은 컴파일 시 크기 결정
heap, stack 영역은 런타임 시 크기 결정

Stack의 지역변수는 사용되고 소멸되기에 데이터 용량이 불확실하다. 
그렇기 때문에 밑에서부터 채워올리고, Heap은 위에서부터 채워나간다.
이렇게 서로 주소값을 채워나가다가 Heap에서 Stack 방향으로 영역을 침범하는 경우 'HEAP overflow'라고 하며 반대로 Stack에서 Heap 방향으로 영역을 침범한다면 'STACK overflow'라고 한다.

```

* 참고

[https://jinshine.github.io/2018/05/17/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B8%B0%EC%B4%88/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0/](https://jinshine.github.io/2018/05/17/컴퓨터 기초/메모리구조/)